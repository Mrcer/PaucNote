# 计算机中的运算
## 基本运算
### 加减法
减法使用补码表示，从而将减法统一为加法。使用全加器运算，记减法运算信号为`sub`，则减法可以通过在B输入端异或`sub`并在最低位进位加`sub`实现。全加器逻辑为$S=C_i\oplus(A\oplus B)$、$C_o=C_i\cdot(A\oplus B)+A\cdot B$。为了减少计算延迟，可以采用超前进位，每一位进位由本位开始的前面所有位的生成函数（$g_i=A_i \cdot B_i$）与途中的传递函数（$p_i=A_i\oplus B_i$）的积的和决定。为了防止电路过大，可以分组超前进位，组与组间行波进位
### 位移运算
位移可以通过一组二选一数据选择器实现，比如二选一导通时$R_1$输出$X_0$即完成一位位移；以此类推完成两位、四位位移后将三组二选一串联即可完成一到七的任意位移。这种实现的优势是只需一个周期即可完成位移。

注意区分逻辑位移（填零）、算术位移（右移时填符号位、左移填零）和循环位移（左移时msb填lsb，右移时lsb填msb）
无符号位移可以当作乘除二的幂次运算；带符号算数位移也可以，但对于负数右移，可以证明舍入方向为负方向（比如-5>>1=-3）
### 逻辑运算
直接将输入按位接入对应逻辑门即可，最后按照操作码与全加器的结果进行数据选择。逻辑运算可以用于控制位状态，比如“与”可用于掩码和清零，“或”可用于置位，“异或”可用于部分取反，“或非”可用于取反和清零
### 条件运算
为了判断两个数的大小，同时节省电路，可以采用两数相减的方式，根据得到的标志位判断。
标志位：

1. `Z`零标志位：或非ALU的所有S输出
2. `N`负标志位：等于最高位的S输出
3. `C`进位/借位标志位：等于$C_{o,N-1}\oplus sub$
4. `V`溢出标志位：表示运算是否溢出，判断方法是当且仅当同号相加且变号时溢出，即$V=A_{N-1}B_{N-1}\bar N+\bar A_{N-1}\bar B_{N-1}N$；或者说，最高位进位当且仅当次高位进位，否则就是溢出，即$V=C_{o,N-1}\oplus C_{i,N-1}$

如此一来，`slt`就可以用$N\oplus V$得到，因为A小于B当且仅当不溢出时A-B为负数或者溢出时A-B为正数。其他情况都可以通过这个和零标志位的逻辑运算得到

无符号比较`sltu`用的是`C`标志位，因为执行减法，此时`C`表示最高位是否借位
> 实际上MIPS并没有向外提供标志寄存器，C标志位可能直接就是最高位全加器的进位，此时无符号`sltu`需要加个非门，但总体还是依赖于C标志位实现，也就是有没有借位
### 乘法
#### 原理
乘法参考手算方法，实际是循环加法。对于被乘数A、乘数B和积C，检测B的每一位，如果为1则将积加上对应移位的A。
#### 实现一
具体实现可以让B循环右移，从而只检测最低位；让A循环左移，条件加给积。按条件加在硬件实现上可以用写使能信号实现。此时A需要64位寄存器，64位ALU

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/059d1fb0-4fbd-11ed-acff-03df3822b3fd_20221019224757.jpeg)
#### 实现二
也可以让A不左移直接加在积的最高位，积循环右移。此时C需要64位寄存器，32位ALU。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/23387830-4fbd-11ed-acff-03df3822b3fd_20221019224847.jpeg)
#### 实现三
由于积和乘数B是同时右移的，因此B恰好可以放在C寄存器的低位，从而节省一个32位寄存器

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/2b7bcba0-4fbd-11ed-acff-03df3822b3fd_20221019224900.jpeg)
#### 带符号乘法
对于带符号数的乘法，需要在对C移位时进行符号位扩展。
#### 并行乘法器
并行乘法器使用更多全加器（平方级），实现单周期乘法（延时大致是普通ALU的两倍）。
具体实现方法是对竖式的每一项用与门求，而全加器按竖式计算流并行计算。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/3d12aa00-4fbd-11ed-acff-03df3822b3fd_20221019224930.jpeg)

为了适配带符号乘法，需要在高位加上符号位扩展加法器，同时最后一层需要改成减法器（取反加一）。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/5eba6300-4fbd-11ed-acff-03df3822b3fd_20221019225026.jpeg)

优化空间：第一位不用全加器；中间的全加器可以不用串行向左进位，直接向下进位，可以节省一半延迟和两行全加器。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/4b4834f0-4fbd-11ed-acff-03df3822b3fd_20221019224954.jpeg)
### 除法
#### 原理
除法也参考手算，实际是循环减法。不断尝试从余数中减去除数，如果成功则商多一位一否则多一位零，之后将被除数从高到低加到余数，重复过程（省略一大波位移，具体见实现）。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/72479320-4fbd-11ed-acff-03df3822b3fd_20221019225059.jpeg)

#### 实现一
初始时32位被除数放在64位余数寄存器的低32位中；32位除数放在64位除数寄存器的高32位，低32位补零；32位商初始化为零。
对n位商和余数，执行n+1次循环，每次循环`余数 -= 除数`，如果余数小于零则还原余数（加回除数）商左移低位置零，否则商左移低位置一；然后除数右移（对应上商移位过程），重复循环。
第一次循环只要除数不为零，商就必然会得到零，因此循环n+1次后商溢出一位是合法的。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/7a7bf270-4fbd-11ed-acff-03df3822b3fd_20221019225113.jpeg)

#### 实现二
先移位再减可以减少一次循环次数；将除数右移改为余数左移可以将除数寄存器和ALU优化为32位，此时ALU每次都是对余数寄存器的高32位和除数运算。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/83551d40-4fbd-11ed-acff-03df3822b3fd_20221019225128.jpeg)

#### 实现三
与乘法类似，商可以放在余数寄存器的低位（每次设置余数寄存器的最低位），从而节省一个寄存器。

![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/8e8a8790-4fbd-11ed-acff-03df3822b3fd_20221019225147.jpeg)

算法最终流程：

1. 初始化除数D和余数寄存器R（记高32位为RH，低32位为RD，最低位为R0；RH清零，RD放被除数）
2. 左移R
3. 计算`RH = RH - D`
4. 若`RH < 0`则`RH = RH + D`，`R0 = 0`否则`R0 = 1`
5. 跳转到步骤2，循环32次
6. RD即为商，RH即为余数
#### 带符号数除法
最简单的方法是记住符号，然后执行正数除法，最后再修正商和余数
### 浮点运算
#### 浮点数表示
单精度浮点数共32位，内容如下：

1. 0-22位（共23位）为尾数位F
2. 23-30位（共8位）为阶数E（偏置127）
3. 31位为符号位S

双精度则有52位尾数，11位阶数（偏置1023）和1位符号
> 阶数实际上是通过加上一个偏置，将负数映射到正数范围，便于比较也便于表示特殊值

浮点数先按以下规则分类：

![](3.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/21657fa0-51af-11ed-ba24-4d050ea47353_20221022101333.jpeg)

规范化单精度浮点数计算为$N=(-1)^S\times(1+F)\times 2^{E-127}$
非规范化浮点数阶数全零。除了零以外，指数被固定为`-(偏置-1)`，比如单精度就是`-126`（而不是`-127`），同时去除尾数的前导一。比如非规范化非零单精度浮点数计算为$N=(-1)^S\times F\times 2^{-126}$。由于情况特殊且实现成本高，有的CPU会把所有非规范数都视作零。
除了规范数和非规范数，其他都是无穷（比如计算除以零时）或非数（NaN，比如计算根号负一时）
#### 异常情况
浮点运算定义了五种异常情况
1. 无效操作：对无限数或非数NaN操作
2. 除以零
3. 数字过大导致阶码上溢
4. 数字太小导致阶码下溢
5. 由于舍入导致结果不精确

硬件可以检测异常，并让硬件或软件处理

> 溢出的意思是规范数变非规范（阶数全零或全一）
#### 浮点数加减
此处介绍规范数加减

1. 求阶差
	比较两数阶码（由于阶码用移码表示，此处不需要用减法判断标志位的方式比较，而是直接用组合逻比较，具体见数电），将两个阶码相减（阶码加减法见一小节）并根据阶码比较结果决定结果是否需要取负。最后将阶码比较结果和阶差（绝对值）传到下一级控制电路
2. 对阶
	根据阶码比较结果，将较小数的尾数右移阶差次对齐小数点。此处要注意两个尾数的最高位应加入额外触发器储存初始隐含的一，最低位保留两位附加位用于舍入操作（只有一位的话就只能用“入”没有“舍”，容易导致统计学误差，详细分析见舍入）
3. 尾数相加减
	添加保护位防止计算时上溢，根据符号位和操作码决定无符号加减操作。

4. 规范化
	在尾数加减完成后，如果符号改变则需要取负并修改结果符号位（默认与被操作数相同）；如果尾数不为零且有前导零，则需要左归直到最高位为一；如果保护位为一则需要右归
	> 右归：尾数右移，阶数加一，判断阶码上溢
	> 左归：尾数左移，阶数减一，判断阶码下溢
	
5. 舍入
	右归后需要舍入，根据标准用于舍入的附加位有两位，有四种舍入方式：就近舍入、朝正方向舍入、朝负方向舍入、朝零舍入。舍入操作可能需要执行加法，并且可能需要重新规范化。
6. 置零
	发生阶数溢出时需要将尾数置零
	
![](3.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/2d0418c0-51bf-11ed-b0bf-c396cad3fdd8_20221022120824.jpeg)

#### 浮点数乘除
此处讨论规范数乘除

1. 阶码相加减
	乘法加除法减，判断是否溢出
2. 尾数相乘除
	此处不讨论硬件实现，只需知道尾数相乘除，并判断阶码是否溢出即可
3. 规格化
	根据数学不难证明，乘法最多右归一次，不左归；除法最多左归一次。
4. 舍入和判断是否需要重新规格化
	与加减法类似
5. 确定符号位
两个阶码相加（8位）：

![](3.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/fbabe2f0-5121-11ed-8c42-331cbfea021f_20221021172315.jpeg)

两个阶码相减：

![](3.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/cffb8a60-5122-11ed-8c42-331cbfea021f_20221021172907.jpeg)

#### 小结

![](3.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/dd0677c0-51c1-11ed-b0bf-c396cad3fdd8_20221022122739.jpeg)

#### MIPS浮点指令
MIPS浮点运算用专用协处理器完成，设置了32个独立的浮点寄存器（f0-31），加入了两条浮点存取指令`lwc1`（根据MARS的指令说明，意思是load word into coprocessor 1）和`swc1`，相关单精度指令见下表

![](3.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97_md_files/433c3d40-51c2-11ed-b0bf-c396cad3fdd8_20221022123030.jpeg)

#### 精度问题
浮点数除了有表达范围的问题，还有进制转换和运算过程的精度问题，这导致浮点数运算结果可能偏大或偏小。实际应用时应注意累次运算产生的统计学误差和数量级差异过大的数运算导致的舍入误差
