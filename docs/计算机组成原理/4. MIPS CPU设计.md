# MIPS CPU设计
## 处理器概述
### 计算机五大组成
1. 控制器（对指令译码并控制数据通路的元件）
2. 数据通路（指令执行时，数据所经过的路径）
3. 存储器
4. 输入
5. 输出
> 控制器和数据通路组成CPU
### 控制器基本功能
1. 取指令
2. 分析指令
3. 控制指令执行
4. 确定下一条指令的地址
5. 执行环境的建立和保护
### CPU设计过程
1. 分析指令集，得出datapath需求
2. 选择datapath包含的模块
3. 组装datapath
4. 根据指令集决定datapath中需要的控制信号
5. 设计控制信号逻辑
> 并不完全独立，很多步骤相互交织，比如datapath组装时就已经确定控制信号了，或者组装datapath时需要更多模块。在ppt中实际组装过程是不断增加对指令的支持完成的，过程中会得到需要的模块以及控制信号
## 设计Datapath
数据通路包括ALU、寄存器堆、多路选择器等。以下开始设计单周期MIPS CPU的datapath
### 根据指令集分析datapath组成
![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/29cc5fa0-569c-11ed-861b-cbad2e16ec09_20221028164023.jpeg)
![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/ce6d93f0-569f-11ed-861b-cbad2e16ec09_20221028170627.jpeg)

1. 存储器（指令存储器、数据存储器）
2. 寄存器（32x32bit）
3. 程序计数器PC
4. ALU
5. PC更新电路
### 设计datapath的模块
datapath的模块分组合逻辑电路和时序逻辑电路。组合逻辑电路要考虑延迟，时序逻辑电路要关注时钟触发。每次时钟触发时时序电路进行状态改变，然后输出的状态经过组合电路输出下一状态，下个时钟触发时循环这个过程。
#### 取指单元
每次时钟触发时先向指令存储器传送PC取出指令，若是顺序指令则PC+4，若是跳转指令或有异常则让控制器控制其他元件算出对应地址存入PC（取指单元依然是PC+4，但控制器让PC存入端的多路选择器选择其他信号）。
#### 译码单元
根据取到的指令从各域中得到数据，并对必要的指令数据进行解码——首先取出opcode，决定指令类型（rt、it、jt），然后根据指令类型取值发信号。
> 控制器还要根据状态（标志位）来决定具体控制信号
#### 寄存器堆
单个寄存器：包含时钟、输入输出和写使能（可选）
寄存器堆模块（`32x32`）：三个选通信号（`rw`、`ra`、`rb`，5bit宽度），三个`bus`口（`busW`、`busA`、`busB`，32bit宽度），时钟和写使能。每个寄存器不设写使能，而是通过时钟控制写入——时钟信号由rw选通信号（经过译码）、写使能信号和寄存器堆时钟相与得到；而输出则由多路选择器决定输出哪一个寄存器信号。
由此可见，写入同步读取异步。
#### ALU
相关指令：加减乘除、移位、逻辑、比较，以及偏移地址的计算
需要实现的运算：加减乘除、移位、逻辑
这些都在上一章介绍过，只要将运算组合起来，并引出两个数据输入、一个数据输出、功能控制输入、标志位输出即可
### 组装datapath
![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/72cd7650-569f-11ed-861b-cbad2e16ec09_20221028170354.jpeg)

#### 取值阶段
为了支持跳转指令，PC寄存器输入要加入数据选择器`PCSEL`，除了取值模块的PC+4外还有可能是：`j`指令的跳转地址、分支指令的跳转地址、`jr`指令要求的寄存器输出，以及重置/中断/异常发生时的跳转地址
> 重置：计算机重启时初始化PC  
> 中断：外部输入中断信号（比如需要处理I/O事件）  
> 异常：非法指令引起的硬件错误  
> 
> 硬件实现的异常是要比高级语言的异常更底层的
#### 译码/读寄存器阶段
rt指令：将译码模块的寄存器选通信号连接到寄存器堆，op、shamt和func经过译码传送到ALU
完整周期如图：
![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/019886d0-56a1-11ed-861b-cbad2e16ec09_20221028171503.jpeg)
写地址Rw可能是寄存器选通信号（rt指令时为rd，it指令时为rt）或某些特殊寄存器（比如`jal`时使用的`$ra`），由控制器控制数据选择器选择。
#### 执行阶段
ALU经过数据选择器（`ASEL`和`BSEL`，由控制器控制），从寄存器、立即数（需要扩展模块扩展到32位）、`shamt`等地方获取输入

`ASEL`负责选择`rd1`、`shamt`（位移指令）和16（`lui`指令），`BSEL`负责选择立即数和`rd2`

结果输出接到寄存器堆的`busW`，用使能（`WERF`，由控制器控制）决定是否写回，也经过数据选择器接到内存`Addr`，便于执行可能的访存

标志位输出接到控制器，在`slti`中用于决定写0/1

对于分支指令，由于需要同时执行比较和地址运算操作，因此对于单周期CPU需要加入额外的ALU处理

总结：主ALU负责计算R-type/I-type、beq的比较（减法）、l/s指令的地址计算
#### 访存阶段
从内存中读取或写入数据。只有load和store需要此步，其他指令跳过。可以用cache加速该阶段
为了执行store，也就是`Mem[ R[rs] + SignExt[imm16] ] <= R[rt]`，需要选通ALU对的运算结果到`addr`，将寄存器堆`rd2`连到内存输入，并开启写使能
#### 写回阶段
将计算结果写回寄存器。这部分为了决定写入数据，引入`WDSEL`，可选择ALU、内存输出（`lw`）、PC+4（`jal`）

![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/aa6e7940-56a6-11ed-861b-cbad2e16ec09_20221028175533.jpeg)

![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/fbf9b7c0-56a6-11ed-861b-cbad2e16ec09_20221028175750.jpeg)

## 设计控制器
控制器其实是个大型组合电路，根据输入求出对应输出，因此实现上就是翻译真值表。设计过程大致是：列出所有指令需要的信号、汇总各指令的控制信号取值、对ALU单独设计局部控制单元（ALUctr）、设计主控制单元。
> ALU部分单独设计的原因是该模块比较复杂且相对独立，分开设计可以减小控制器规模

1. 输入包括opcode和func，以及ALU的标志位（Z、N、V）
2. 确定每条指令的控制信号（0/1/X）
### 所有指令需要的信号
以add指令为例的所有信号：

![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/9cf6d710-5a8b-11ed-bfe3-bf1ea9f61487_20221102165158.jpeg)

控制器视角：

![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/71f84250-5a8c-11ed-bfe3-bf1ea9f61487_20221102165756.jpeg)

### 汇总取值
以ALU控制单元为例

![](4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/d8a2f770-5a91-11ed-bfe3-bf1ea9f61487_20221102173636.jpeg)

接下来可以用列出SOP化简，或者用类似FPGA思路来设计
### 单独设计ALU控制模块
从主控制器中获取控制信号，从译码模块获取func（不再送去主控制器），处理后输出到ALU
## 多周期CPU设计
### 单周期CPU的困境
涉及访存阶段的指令只有两条，但这个阶段却是最耗时的。由于单周期CPU的周期长度由最长延时指令决定，因此单周期CPU效率很低。
### 多周期概述
在多周期CPU中，一条指令要经过多个周期才能执行完成。这种实现更加复杂，但频率可以更高，而每条指令可以根据需要调整占用周期数从而减少执行时间，并且很多部件可以得到复用。

基本实现思想是将控制器改为有限状态机，不同指令经历各自的状态流程，而在每个状态中组件就可以得到复用（比如加法器）

最终指令执行效率取决于阶段的划分和不同指令的比例。
### 各个阶段的改动
由于一条指令会经历多个周期，控制器不再是组合逻辑电路，而是改成状态机。主要状态分支是R-type，I-type，lw，sw，j
#### 取值阶段
1. 因为不是每个周期都要改变PC，PC增加写入使能；
2. 加入IR，在阶段末尾保存PC值
3. ALU复用，在该阶段计算PC+4并在下一周期下降沿存入PC寄存器；PC改变时指令已经写入到IR中且后续没有写使能，不用担心PC改变对其他组件的影响；
#### 译码阶段
1. ALU复用进行投机计算，计算`PC+signext[imm]`（PC已经在取值阶段+4了）并存入target寄存器（带写使能，不需要ALU选通），在后面会用控制器决定是否需要改写PC
2. 寄存器堆末尾加入
#### 执行阶段
1. 根据是否为分支指令且Z=0来决定是否把target写入PC
2. 为解决写回阶段的竞争问题（实际上寄存器是异步的，写使能前后一段时间信号要稳定），控制器要在这一阶段就选通好Rw和busW
> 竞争问题：当存储元件是异步时，输入信号不能和写使能同时发出，否则会不稳定。输入信号必须在整个写使能期间保持稳定。
#### 访存阶段
此阶段只有l/s指令才会进行，其他指令跳过，下一阶段也是只有部分指令会进行。

1. 此阶段要保持ALU输出稳定，确保内存模块地址稳定
#### 写回阶段
1. 此阶段ALU输出要保持稳定，确保寄存器正确写入
## 流水线设计
流水线设计在多周期CPU的基础上（但为了避免冲突，每条指令占用周期相同，被称为*规整化*）允许多条指令同时执行，这能降低CPI，提高吞吐率。但也会延长指令执行时间（引入了更多寄存器），而且引入三种冒险——控制冒险、数据冒险、结构冒险。

基本实现思想是，将执行过程划分为多个阶段（上面已划分），每一阶段最后设置存储元件（被称为**流水线寄存器**），每个周期将上一阶段的运行结果计算完后存在当前阶段末的流水线寄存器供下一阶段在下周期读取。

最终指令执行效率取决于耗时最长阶段

![](./4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/1.jpg)
### 各个阶段的改动
控制器改回组合逻辑电路，在译码阶段产生所有控制信号，并流水线化（在各个阶段设置寄存器保存控制信号）。
#### 取值阶段
1. 增加+4加法器（也就是改回单周期CPU的加法模式）
2. 将IR改为IF/ID寄存器，保存*PC+4*和指令。
#### 译码阶段
1. 阶段末增加ID/EX寄存器，保存PC+4、Imm16、Reg[Rs]、Reg[Rt]、Rt、Rd
#### 执行阶段
1. 阶段末增加Ex/Mem寄存器，保存PC+4、Rt/Rd（通过控制器选择）、计算结果、标志位、Target（分支指令的跳转地址）
2. 在ALU之外增加一个加法器计算Target（跳转指令中ALU需要进行比较运算，无法计算跳转地址）
#### 访存阶段
1. 阶段末增加Mem/Wr寄存器，保存访存结果、计算结果、目标寄存器
2. 增加分支指令是否跳转的判断，用于设置PC
#### 写回阶段
1. 将写信号和时钟相与，也就是在下半周期完成写入，从而解决地址和写信号的竞争
2. 选择计算结果/访存结果来保存
### 控制器的改动
1. PC不需要写控制信号
2. 流水线寄存器不需要写控制信号（非阻塞，但有清空信号来为下面的冒险服务）
3. 取值和译码不需要控制
### 冒险
#### 结构冒险（资源竞争）
指令**使用相同硬件块**：不同指令执行周期数不同，这就有可能导致不同指令处于同一阶段。

有一种情况必然发生，那就是译码阶段和写会阶段同时使用寄存器堆，解决方法是前半周期（末尾的边缘）写回，后半周期（末尾）读取

同理存储器也有这种问题，也就是取值和访存阶段都要用存储器。可以使用两个存储器，也可以像上面一样周期分开两部分使用
#### 数据冒险
指令数据依赖于流水线指令的其他结果，也就是**与寄存器有关**：load指令在写回阶段才改写寄存器堆，此时已经有3条指令使用了旧的寄存器值，这就是数据冒险。

一种解决方法是进行冒泡，也就是插入空白周期（阻塞流水线），直到寄存器得到更新。分为软件和硬件阻塞。软件阻塞是让编译器分析依赖后在发生数据冒险处插入nop指令，nop是不改变计算机状态的指令。硬件阻塞是阻止PC、IF/ID寄存器（取值阶段末的寄存器）更新并清空ID/EX寄存器（译码阶段末的寄存器，主要要清空控制信号）

另一种解决方法是转发，这对除lw指令外是有效的，因为数据在执行阶段就有效了，而即使是下一条指令就需要该数据，因为译码就在执行的上一阶段，这个数据可以直接转发过去从而让下一条指令取得新值。具体原理是引入转发控制器，控制ALU从中间寄存器中获取输入（转发是临时的，寄存器堆存的依然是旧值）。转发有三条回路，C1：执行尾到执行头（相邻指令冲突）；C2：访存尾到执行头（隔一条指令ALU结果冲突）；C3：访存尾到执行头（隔一条指令访存结果冲突）。对于lw指令，由于数据在访存阶段才能得到，转发只能提前一个周期（在写回之前转发），因此无法解决相邻指令的数据冒险。这被称为载入-使用冒险，只能冒泡。

![](./4.%20MIPS%20CPU%E8%AE%BE%E8%AE%A1_md_files/2.jpg)

还有一种方法是让编译器调整指令顺序来消除依赖

#### 控制冒险
取指令依赖于流水线指令的其他结果，比如分支指令在访存阶段才能改写PC，此时已经有3条指令被取出，这就是控制冒险，也就是**与PC有关**。这会在所有改变PC的指令中发生。

解决方法有冒泡、提前判断、预测、延迟分支

对于j指令，需要阻塞一周期

对于分支指令，直接冒泡可以硬件阻塞（清空流水线寄存器）也可以软件阻塞（插入nop指令），需要阻塞三周期（写回阶段初期才改写PC）。提前预测就是利用转发思想提前使用分支结果——
转发执行阶段的比较结果则要阻塞两周期，引入专用比较器和转发电路将比较放在译码阶段则要阻塞一周期。如果想减小阻塞带来的性能损失，可以使用分支预测，也就是假设一种分支结果，直接执行对应的指令，这对于循环语句很有效。

假设不发生跳转，则在分支发生时除了改写PC，还需要清除分支指令后的流水线内指令，并确保他们没有改变机器状态

假设发生跳转的话每条分支都引入一周期阻塞（因为要在译码后才能知道是跳转指令）。

还可以利用运行时信息动态预测，比如记录PC前后一段区域（通过仅保存有限位低地址实现）分支指令的上次跳转结果，然后总是假设该分支指令和上次跳转结果相同。实现方式是引入分支历史记录表BHT，在取值阶段检查PC是否在BHT中，命中（该分支指令执行过且记录在表内）时就按上次结果预测，未命中时就初始化缓存并使用默认预测；在判断出指令类型（因为缓存有范围，低地址相同的可能是其他指令）和跳转结果后更新缓存并按情况调整流水线。动态预测效率高，被广泛使用。

另一种减小阻塞代价的方式是延迟分支。延迟分支是指分支指令后紧跟的指令必须执行，这需要编译器挑选无论分支与否都会执行的指令放在分支指令后，如果找不到就填nop。而紧跟的指令数（*分支延迟槽*）取决于取到分支到PC改变的周期数。这种设计简单但不如动态预测。mips采用了，分支指令后一条指令必定执行。
