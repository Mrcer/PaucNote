# 存储器层次结构
## 概述
存储器按介质分有半导体类、磁表面类、磁芯类、光盘类；按存取方式分有随机访问的RAM、ROM和串行访问的磁带和磁盘

不同存储器单位存储成本不同，一般单位存储成本越高访问带宽越大延迟越低

计算机存储层次分为外存（磁带/光盘/磁盘HDD/固态硬盘SSD）、内存（DRAM）、寄存器。除此之外还有为了解决主存容量不够而在外存上开辟的虚拟存储空间（硬盘当内存用）、为了解决内存和CPU（寄存器）速度不匹配而引入的缓存（分多级的中间存储）。

局部性原理是指程序在任何时候都倾向于只访问小部分地址空间。时间局部性是指最近访问的数据项很可能马上被再次访问，空间局部性是指最近被访数据项的临近数据项可能很快也将被访问。局部性原理是计算机存储层次设计的原因（将更可能使用的数据在更快的存储器中同步）。

三级存储结构是指将缓存、内存和虚拟存储器综合起来，向用户（运行的程序）呈现统一的内存结构

命中是指数据在高层存储结构中出现；失效是指需要从低层存储结构中找回数据

位是一个0/1，存放一个位的电路称为存储元；存储字是存储器每次存入或取出的整个二进制数；存储单元是存放字或存放字节的主存空间，每个存储单元对应一个地址；大量存储单元构成存储体

B（Byte）表示字节，b（bit）表示位。前面可接量词，其中根据ISO标准，Ki/Mi/Gi遵循1024进制，比如1KiB=1024B，而K/M/G遵循千进制。（Windows系统不遵循ISO标准）

存储速度有三个指标：访问时间（从CPU发出命令到读出信息所需时间，也就是延迟）、访问周期（连续两次访问的最小间隔时间）、存储器带宽（连续访问时的数据传送速率）

SRAM的存储元由晶体管组成，核心结构是双稳态触发器；DRAM的存储元由晶体管和电容组成，核心结构是电容。

DRAM每次读出由于电容放电需要进行**读出重写**，而由于漏电又要**定时刷新**。

芯片存储容量=$2^M\times N$，其中M为地址线根数，N为数据线根数

译码可分为单译码和双译码（二维译码，需提供行地址和列地址）。DRAM使用双译码，分两次从相同端口送入行地址和列地址

存储芯片引脚一般包括：地址线、数据线、控制线（读写控制和片选控制）、电源线、接地线。对于双译码芯片DRAM一般会共用地址线需要加入行选通和列选通信号。

ROM只读存储器分为MROM（不可擦写）、PROM（可写一次）、UVEPROM（UV擦写）、E2PROM（电擦写）、Flash（块擦写）
## 主存储器
主存储器由存储芯片（DRAM或ROM）、地址寄存器、地址译码器、刷新控制电路等组成。

### 字位扩展
主存中的存储芯片（mK × n位/片）一般包含多块，通过连接组成更大的存储器（MK × N位），这被称为扩展。扩展分为位扩展和字扩展（当然也能同时扩展），比如说要用1K×4位（字宽4位，字数4k）的芯片组成4K×8位的存储器

先进行位扩展：需要扩展多一倍（N/n）的存储芯片。将加入芯片的数据线直接和之前的拉到一起组成8根，而地址线连接和之前的芯片一样。

再进行字扩展：需要再扩展多一倍（M/m）的存储芯片。将加入芯片的数据线接到一起，而地址线要加两条，译码后接到存储芯片的选通信号。

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/1.jpg)

由此，共需(M/m)*(N/n)块存储芯片

### 负载计算
由于主存储器内包含多个存储芯片，而地址线等是同时向这些芯片供电的，因此一般来说都需要加入门电路来增强供电能力，有时甚至需要多级门电路供电

### 速度估算
系统存储周期$T_{RM}$包括：

1. 芯片存储周期$T_{RC}$：芯片参数决定
2. 系统传输时延$t_D$：外围电路逻辑级数决定
3. 系统恢复时间$t_R$：需要系统测试
### 连接到CPU
存储器通过地址线、数据线、控制线连接到CPU

地址线：低位连接、高位片选

数据线：连接到多个位扩展的存储芯片

控制线：读写命令线、MREQ内存/IO选择线

CPU和主存可以采取异步通信和同步通信。异步是指CPU发送请求后等待存储器发回完成信号后取数；同步是指CPU和主存使用同一时钟信号，请求发出后等待确定的周期数就取数。

主存空间可包括ROM和RAM
## Cache高速缓存
由于CPU和主存速度差距很大，而又因为局部性原理，引入速度介于CPU和主存的高速缓存可以提高存取数据的效率。

> 缓存技术广泛用于协调数据交换设备的速度，除了CPU缓存，还有网络缓存、浏览器缓存等等

Cache制作在CPU芯片中，由SRAM组成，只存放主存中最近访问的某些**块**（Cache中称为**行**，两者大小一致），并在适当时候与主存同步。

块/行的大小可以任意选取。通常来说，块/行越大空间局部性越好，越小时间局部性越好。
### 命中与失效
由于Cache只保存主存的部分数据，因此CPU访存时不一定能从Cache中获取所需数据。如果能就被称为命中，直接从Cache中读写，缩短延迟；否则称为失效，需要从主存中读写到Cache并送到CPU，没有缩短延迟。因此Cache重要的参数就是命中率、命中时间、失效率、失效时间，并可以基于这些参数计算平均访问时间、加速比。

由于失效后需要将块读入Cache，因此有**提前重启**技术，一旦读到所需数据就返回给CPU，而不必等Cache修改完毕，从而缩短失效时间。
### 映射方式
为了实现只保存主存的部分以及与保持与主存一致，Cache的行都要附带Tag标志域（用于区分不同块）和V有效位（用于解决开机时的未初始化问题）。

在开机时将V全部初始化为0，表示失效；每次访存后将数据保存在特定部分并将V置为1，表示有效。

Tag存放的内容取决于怎么将内存映射到Cache，映射方式包括直接映射、全相联映射、组相联映射。
#### 直接映射
直接映射是指将主存的每一块映射到Cache中的固定行中，映射方式是取模。

具体来说，将主存的每一块用页来唯一标记，然后将页按顺序划分为多个组，Tag只保存组号。每次访问Cache时将页号（地址/块大小）除以组数，商就是组号，余数就是行号，取出该行组号（Tag）比对，一致则命中，否则失效。

举个例子，如果主存有1MB（20位地址），设置每块/行512B（9位页内地址），则要划分出2048页，设置每16页（4位页号）一组，则总共有128组（7位组号）。这样Cache容量为8KB，每一行包括7位Tag，1位V和512B数据页。

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/2.jpg)

实现上，组号、组内页号（页号mod组大小，也就是行号）和页内地址是在主存地址上顺序排列的，因此不需要真的取模，只需加上比较器比较地址中4位译码选通行的Tag和地址的高7位，并与选通行的V相与，即可知道是否命中。如果命中就用地址的低9位接多路选择器来选择数据页即可读出该地址数据。

直接映射的优点是容易实现、命中时间短；缺点是会有多个块固定地对应同一行，如果要经常访问这些块就会发生频繁的失效，即使其他行是空闲的，这被称为*Cache抖动*
#### 全相联映射
全相联映射是指主存块可装到Cache中的任意一行，因此Tag需要保存完整页号

实现原理很简单，每一行分配一个比较器比较查询的页号与Tag是否一致，将比较器结果取或即可得知是否命中，命中后打开对应数据的三态门即可；不命中就按一定规则替换掉某一行，比如让行按顺序排列，记录最新替换块，从而形成类似循环队列的结构，每次替换最老的行。然而比较器很大很慢，因此应用很少
#### 组相联映射
组相联映射采用组间模映射、组内全映射

原理与直接映射类似，先给块编号，再将块顺序均分为多个组群（对应直接映射中的组），组群内的块相对地址记为组号。Cache中则分出多路，每个路有多个行，Tag保存组群号。具体原理如图，为4路256行Cache，先根据组号选中行，然后将四个选中行的组群号与目的组群号比较判断是否命中并输出
![](5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/138bab10-7613-11ed-af77-cf61b8a8a257_20221207173944.jpeg)

为了研究Cache命中概率，引入关联度来表示每个内存块能存放的Cache行数，可以发现直接映射的关联度为1，全相联为Cache行数，N-路组相联映射为N。一般来说，相同Cache行数下关联度越高缺失率越低。

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/3.jpg)
### 一致性问题
有三种情况会导致Cache与主存数据不一致：

1. Cache内容被CPU更新但主存没有
2. 其它设备修改了主存而没修改Cache
3. 多核CPU且各自有私有Cache时，某个核心修改私有Cache导致其他核心Cache和主存与该私有Cache不一致

这里只介绍第一种情况的解决，也只考虑第一种情况。

假如写命中，有两种处理方式：写直达和写回。

写直达是指修改数据时同时修改Cache和主存。为了减少主存访问慢对CPU的影响，可以采用写缓冲机制，也就是先存入缓冲，等待写入完成时，CPU可以执行其他指令。不过缓冲满了CPU依然要被阻塞。

写回是指只修改Cache数据。这要求Cache增加脏位标志，表示数据是否被修改过。在替换被修改过的数据前要先将数据写回主存。

假如写不命中，有两种处理方式：写分配和写不分配。前者会在Cache中分配空间，能提高空间局部性，但要从内存中读取完整的块；后者直接写内存，不需要增加读内存操作，但没有利用空间局部性。两种方式都要写内存，区别在于要不要读内存。
### 失效类型
* 强制失效：首次访问
* 容量失效：由于容量不足被替换导致的失效
* 冲突失效：由于映射到满载的组而被竞争替换导致失效（在直接映射和组映射中发生，此时Cache不一定装满）
### 替换规则
非直接映射的Cache在发生冲突失效时需要按一定规则选择被替换的行。常用的规则有：先进先出FIFO、最近最少用LRU、最不经常用LFU、随机替换

先进先出对Cache中的每一组加入一个指针，记录下一个应被替换的行，初始为零。每次要写入新行，先按顺序填充空行，满了之后就填充指针指向的行，并递增指针（指针满了就清零）。

最近最少使用LRU对每行设置一个计数器（LRU位），每次写入时将写入行计数器清零，其他同组里的行计数器递增（满了就不变）。发生冲突时选择计数值最大的行替换。

随机替换会使用硬件随机数选择一行替换

FIFO和LRU在极端情况下会发生频繁的冲突，被称为抖动。随机规则实现成本低，性能略差于LRU算法。
### 多级Cache
现代处理器中一般进一步将Cache分为L1、L2和L3，容量依次增大，速度依次减慢、依次远离CPU（但通常CPU和Cache都在一个芯片上）

L1缓存有两块，L1数据缓存和L1指令缓存，这被称为**分立**缓存，命中时间较短。L2、L3则不区分数据和指令，称为**联合**缓存，命中率较高
## 虚拟存储器
Cache采用硬件实现CPU和主存的缓存，而虚拟缓存器则采用硬件配合操作系统实现主存和硬盘的缓存，同时实现应用隔离等功能。
### 基本概念
* 分页：将程序划分为多个统一长度的页，在主存中用页框来保存
* 逻辑地址：程序使用的地址，空间比实际主存大得多
* 物理地址：Cache和主存使用的地址
* MMU：负责将逻辑地址转换为物理地址的硬件，通常和CPU放在一个芯片上

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/4.jpg)
### 分页虚拟存储器
分页管理将程序和主存都按页划分，逻辑地址和物理地址的低位是对应的，用来编码页内地址，而高位则分别用来编码虚页号和实页号，用页表来建立虚页号和实页号的映射关系。

每次程序启动时，操作系统在主存中为其创建一个页表。页表中每一项记录了装入位、访问权限、使用情况、修改位、磁盘地址或页框号，这些项采用全相联映射。页表记录每个虚页是否分配了主存空间，如果没有则称为缺页，由操作系统负责分配空间和加载数据。如果缺页时主存空间不足，则要将其他页替换掉，替换算法类似Cache，根据脏位（是否被修改过）决定是否要写回硬盘。页表首地址由操作系统加载到页表基址寄存器中

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/6.jpg)

地址转换需要访存，同样可以引入对应Cache来加速，以虚页号来设计Tag或index，称为快表（TLB）。于是访存有三种缺失的可能：TLB缺失、Cache缺失和缺页，具体情况如下。

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/7.jpg)

页式虚拟存储器的优点：实现简单，开销少；缺点：由于页不是逻辑上独立的实体，可能会出现如“一条指令跨页”等情况（CISC），使处理、管理、保护和共享都不方便。
### 段式虚拟存储器
段式管理将程序按自然边界划分为多个段，比如代码段、数据段、跳转表等等，然后根据需要将程序的不同段加载到主存中。每个段可以命名并设置不同的权限，比如读/写/执行，方便编译器和操作系统管理，以及程序间的数据代码共享，但也容易产生内存碎片导致空间浪费。每个程序运行前会在主存中分配到段表，记录段的段名、加载情况、起始位置、段长。与分页不同，段的划分是可以由程序自己决定的。每个段在硬件层面用段号区分，他可以和程序号一起编码在逻辑地址中。

段的异常情况包括：缺段（未装入主存）、地址出界（偏移超出段长）、保护违例（比如尝试修改只读的代码段）

类似地，段式虚拟存储器的虚拟地址中，高位标记段号，低位与物理地址对应，表示段内偏移。在访问虚拟地址时需要查询段表，将段首地址加上段内偏移得到实际地址，并通过比较偏移长度与段长得出是否越界。多用户系统（用户可以理解为程序）中还可再编码进用户号，通过用户号找到对应段表基地址，再继续查询。

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/5.jpg)

段式管理的优点：段的分界与程序的自然分界相对应；段的逻辑独立性使它易于编译、管理、修改和保护，也便于多道程序共享；缺点：容易在段间留下许多空余的零碎存储空间不好利用，造成浪费。

### 段页式虚拟存储器

* 程序按模块分段，段内再分页，主存内则仍以页为基本单位
* 逻辑地址由段地址、页地址和页内偏移组成
* 用段表和页表（每段一个）进行两级定位管理
* 根据段地址到段表中查询与该段相应的页表指针，再转到页表，然后根据页地址从页表中查到该页在主存中的页框地址，由此访问到页内某数据

![](./5.%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84_md_files/8.jpg)