<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>计数与组合 - 咩咩的笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u8ba1\u6570\u4e0e\u7ec4\u5408";
        var mkdocs_page_input_path = "\u79bb\u6563\u6570\u5b66\\8-\u8ba1\u6570\u4e0e\u7ec4\u5408.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 咩咩的笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">主页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">笔记</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">离散数学</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../2-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/">命题逻辑</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../3-%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/">一阶逻辑</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../4-%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95/">证明方法</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../5-%E9%9B%86%E5%90%88/">集合</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../6-%E5%85%B3%E7%B3%BB/">关系</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../7-%E5%87%BD%E6%95%B0/">函数</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">计数与组合</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#_2">组合计数的基本原理</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_3">加减乘除</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_4">容斥原理</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_5">鸽笼原理</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">排列与组合</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_7">二项式定理与组合等式</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_8">允许重复的排列与组合</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_9">再论容斥原理及其应用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_10">排列与组合的生成算法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_11">递推关系式</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_12">技术问题的递推关系式建模</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_13">线性递推关系式求解</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_14">分治算法与递推关系式</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">咩咩的笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>笔记 &raquo;</li>
          <li>离散数学 &raquo;</li><li>计数与组合</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">计数和组合</h1>
<h2 id="_2">组合计数的基本原理</h2>
<h3 id="_3">加减乘除</h3>
<ul>
<li>记集合S的元素数量为|S|</li>
<li>（定义8.1）<strong>加法原理</strong>：若集合S有划分<span class="arithmatex">\(F=\{S_1,\cdots S_n\)</span>，则</li>
</ul>
<div class="arithmatex">\[|S|=|S_1|+\cdots+|S_n|\]</div>
<blockquote>
<p>不重不漏地分类，简化元素数量运算
* （定义8.2）<strong>乘法原理</strong>：若集合S的每个元素都是个元素构成的序列（n元组）<span class="arithmatex">\(\langle s_1,\cdots,s_n\rangle\)</span>，每个元素<span class="arithmatex">\(s_i\)</span>的可，能取值有<span class="arithmatex">\(m_i\)</span>种，且对任意<span class="arithmatex">\(i&lt; n\)</span>无论<span class="arithmatex">\(s_i\)</span>取<span class="arithmatex">\(m_i\)</span>种值的哪个值，<span class="arithmatex">\(s_{i+1}\)</span>都有<span class="arithmatex">\(m_{i+1}\)</span>种可能的取值，则</p>
</blockquote>
<div class="arithmatex">\[\mid A_1\times\cdots\times A_n\mid =m_1\times\cdots\times m_n\]</div>
<div class="admonition note">
<p class="admonition-title">Note<p>注意满足乘法原理的集合，序列前一个元素与后一个元素既有一定<strong>独立性</strong>又可能有一定<strong>相关性</strong>，也就是说前一个元素选择不同，后一个元素可选的值可能不同（相关性），但可选值的数量一定相同（独立性）</p>
</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note<p>应用乘法原理划分任务应优先考虑约束条件多的子任务，并保证后续任务的完成方法数不依赖于这个任务的完成方法</p>
</p>
</div>
<ul>
<li>（定义8,3）<strong>减法原理</strong>：对于全集U
和他的子集S，有</li>
</ul>
<div class="arithmatex">\[|S|=|U|-|\bar S|=|U|-|U-S|\]</div>
<ul>
<li>（定义8.4）<strong>除法原理</strong>：若集合S和集合T之间存在满函数<span class="arithmatex">\(f:S\to T\)</span>，且T的每个元素在f下都恰好有k个原像，则</li>
</ul>
<div class="arithmatex">\[|T|=|S|/k\]</div>
<ul>
<li>（定义8.5）<strong>一一对应原理</strong>：如果有限集合S和集合T之间存在双函数，这他们有相同的元素个数<blockquote>
<p>我觉得这是个定理。。</p>
</blockquote>
</li>
</ul>
<h3 id="_4">容斥原理</h3>
<p>以下集合都默认为有穷集合</p>
<ul>
<li>（引理8.1）<span class="arithmatex">\(|A-B|=|A|-|A\cap B|\)</span></li>
<li>（定理8.2）<strong>两集合容斥原理</strong>：</li>
</ul>
<div class="arithmatex">\[|A\cup B|=|A|+|B|-|A\cap B|\]</div>
<ul>
<li>（推论8.3）<strong>三集合容斥原理</strong>：</li>
</ul>
<div class="arithmatex">\[|A\cup B\cup C|=|A|+|B|+|C|-|A\cap B|-|A\cap C|-|B\cap C|+|A\cap B\cap C|\]</div>
<blockquote>
<p>三集合容斥原理推导的基本思路是将<span class="arithmatex">\(A\cup B\)</span>看作一个集合来运用两集合容斥原理展开，更多集合的容斥原理可以以此类推</p>
</blockquote>
<h3 id="_5">鸽笼原理</h3>
<ul>
<li>
<p>（定理8.4）<strong>鸽笼原理</strong>或<strong>抽屉原理</strong>：设k是正整数，将k＋1或更多只鸽子关到k个鸽笼里，至少有一个鸽笼里有两个或更多只鸽子</p>
</li>
<li>
<p>（推论8.5）设A和B都是有穷集合</p>
<ul>
<li>若<span class="arithmatex">\(|A|&gt;|B|\)</span>，则没有A到B的单函数</li>
<li>若<span class="arithmatex">\(|A|&lt;|B|\)</span>，则没有A到B的满函数</li>
<li>若<span class="arithmatex">\(|A|＝|B|\)</span>，则任意A到B的单函数或满函数也是双函数</li>
</ul>
</li>
<li>
<p>（定理8.6）<strong>广义鸽笼原理</strong>：将N个舞台放到k个盒子，则至少有一个盒子至少有<span class="arithmatex">\(\lceil N/k\rceil\)</span>个物体</p>
</li>
<li>拉姆齐定理</li>
</ul>
<h2 id="_6">排列与组合</h2>
<ul>
<li>（定义8.6）从n个可区别的物体<em>不允许重复</em>地选择r个物体进行<em>有序</em>安排，称为n个物体的r-<strong>排列</strong>。如果n个物体构成集合S，也成为S的r-排列。S的n-排列称为<strong>全排列</strong>。我们用<span class="arithmatex">\(P^r_n\)</span>或<span class="arithmatex">\(P(n,r)\)</span>表示S的r-排列数。</li>
<li>（定理8.7）  </li>
</ul>
<div class="arithmatex">\[P(n,r)=\frac{n!}{(n-r)!}=n(n-1)\cdots (n-r+1)\]</div>
<ul>
<li>（定义8.6）从n个可区别的物体<em>不允许重复</em>、<em>不计顺序</em>地选择r个物体，称为n个物体的r <strong>组合</strong>。如果n个物体构成集合S，也成为S的r组合。S的r组合数记为<span class="arithmatex">\(C_n^r\)</span>或<span class="arithmatex">\(C(n,r)\)</span>。组合数<span class="arithmatex">\(C(n,r)\)</span>也称为<strong>二项式系数</strong>，这时通常记为<span class="arithmatex">\(\binom{n}{r}\)</span></li>
<li>可以将组合数<span class="arithmatex">\(C(n,r)\)</span>理解为n元素集合的r子集数，这种理解方式称为<strong>集合论解释</strong>；也可以理解为长度为n且含r个1的二进制串数，称为<strong>二进制串解释</strong>。组合数学中等式可以通过论证等式两边是对同一个集合元素的不同计数方式来证明，这称为<strong>双计数证明</strong>，也可以论证他们分别是对两个有一一映射关系的集合的计数，这成为<strong>双函数证明</strong>，这两种证明方法称为<strong>组合证明</strong>。等式也可以用更严谨代数法证明，称为<strong>代数证明</strong></li>
<li>（定理8.8）<strong>组合数的对称式</strong> </li>
</ul>
<div class="arithmatex">\[C(n,r)=C(n,n-r),r\leq n\]</div>
<ul>
<li>（引理8.9）<span class="arithmatex">\(r&lt;n\)</span></li>
</ul>
<div class="arithmatex">\[(r+1)C(n,r+1)=(n-r)C(n,r)\]</div>
<ul>
<li>（定理8.10）<span class="arithmatex">\(r\leq n\)</span></li>
</ul>
<div class="arithmatex">\[C(n,r)=\frac{P(n,r)}{P(r,r)}=\frac{n!}{r!(n-r)!}\]</div>
<h3 id="_7">二项式定理与组合等式</h3>
<ul>
<li>（定理8.11）<strong>二项式定理</strong>：设x,y是两个变量，n是正整数，则：</li>
</ul>
<div class="arithmatex">\[\begin{align}(x+y)^n=&amp;\sum_{i=0}^n\binom{n}{i}x^iy^{n-i}\\=&amp;\binom{n}{0}y^n+\binom{n}{1}y^{n-1}+\cdots+\binom{n}{n}x^n\end{align}\]</div>
<ul>
<li>
<p>二项式定理常见的代入展开式：</p>
<ul>
<li><span class="arithmatex">\(当y=1时,(x+1)^n=\binom{n}{0}+\binom{n}{1}x+\cdots+\binom{n}{n}x^n\)</span></li>
<li><span class="arithmatex">\(当x=1,y=1时,\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=2^n\)</span></li>
<li><span class="arithmatex">\(当x=-1,y=1时,\binom{n}{0}+\binom{n}{2}+\binom{n}{4}+\cdots=\binom{n}{1}+\binom{n}{3}+\binom{n}{5}+\cdots=2^{n-1}\)</span></li>
<li><span class="arithmatex">\(当x=2,y=1时,\binom{n}{0}+\binom{n}{1}x+\cdots+\binom{n}{n}x^n=3^n\)</span></li>
<li><span class="arithmatex">\(令y=1后对式子微分得n(1+x)^{n-1}=\binom{n}{1}+2\binom{n}{2}x+\cdots+n\binom{n}{n}x^{n-1}\)</span></li>
</ul>
</li>
<li>
<p>（定理8.12）<strong>帕斯卡等式</strong>设n,k是自然数，且<span class="arithmatex">\(1\leq k\leq n-1\)</span>，有：</p>
</li>
</ul>
<div class="arithmatex">\[\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}\]</div>
<ul>
<li>常用组合等式：<ul>
<li><strong>递推式</strong>:<span class="arithmatex">\(r\binom{n}{r}=(n-r+1)\binom{n}{r-1}=n\binom{n-1}{r-1},1\leq r\leq n\)</span></li>
<li><strong>乘积化简式</strong>：<span class="arithmatex">\(\binom{n}{m}\binom{m}{k}=\binom{n}{k}\binom{n-k}{m-k},k\leq m\leq n\)</span></li>
<li><strong>上下求和式</strong>：<br />
<span class="arithmatex">\(\sum_{k=0}^r\binom{m+k}{k}=\binom{m}{0}+\binom{m+1}{1}+\cdots+\binom{m+r}{r}=\binom{m+r+1}{r}\)</span><br />
<span class="arithmatex">\(\sum_{k=0}^n\binom{k}{m}=\binom{0}{m}+\binom{1}{m}+\cdots+\binom{n}{m}=\binom{n+1}{m+1}\)</span> </li>
<li><strong>朱世杰-范德蒙等式</strong>：<span class="arithmatex">\(\sum_{k=0}^r\binom{m}{r-k}\binom{n}{k}=\binom{m+n}{r},r\leq m,r\leq n\)</span></li>
</ul>
</li>
</ul>
<h3 id="_8">允许重复的排列与组合</h3>
<ul>
<li>（定理8.13）n类物体允许重复的r排列数是<span class="arithmatex">\(n^r\)</span></li>
<li>（定理8.14）每类物体分别有<span class="arithmatex">\(m_1,m_2,\cdots,m_n\)</span>个的n类物体允许重复的<span class="arithmatex">\(m_1+m_2\cdots+m_n=r\)</span>排列数是</li>
</ul>
<div class="arithmatex">\[C(r,m_1)C(r-m_1,m_2)\cdots C(r-m_1-m_2-\cdots-m_{n-1},m_n)=\frac{r!}{m_1!m_2!\cdots m_n!}\]</div>
<ul>
<li>（定理8.15）物体个数不限的n类物体允许重复地选r个物体的方案数，等于长度为n-1+r且有r个1的二进制串个数，等于<span class="arithmatex">\(C(n-1+r,r)\)</span></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>原理是问题可转化为解不定方程<span class="arithmatex">\(x_1+x2+\cdots+x_n=r\)</span>的非负整数解，而这与长度为n-1+r且有r个1的二进制串一一对应</p>
</div>
<h3 id="_9">再论容斥原理及其应用</h3>
<ul>
<li>（定理8.16）<strong>一般形式的容斥原理</strong>：</li>
</ul>
<div class="arithmatex">\[|\bigcup_{i=0}^n A_i|=\sum_{k=1}^n\left( (-1)^{k-1}\sum_{1\leq i_1\leq \cdots \leq i_k\leq n}|\bigcap A_i|\right)\]</div>
<ul>
<li>（推论8.17）</li>
</ul>
<div class="arithmatex">\[N(\bar{P_1}\cdots\bar{P_n})=N+\sum_{k=1}^n\left( (-1)^k\sum_{1\leq i_1\leq \cdots \leq i_k\leq n}N(P_{i_1}\cdots P_{i_k})\right)\]</div>
<ul>
<li>不定方程变种的化归方法：<ol>
<li>若<span class="arithmatex">\(x_i\)</span>有下界<span class="arithmatex">\(a_i\)</span>，即<span class="arithmatex">\(x_i\geq a_i\)</span>，则令<span class="arithmatex">\(X_i=x_i-a_i\)</span>，代入原不定方程即可消除下界（将下界变为0）</li>
<li>若<span class="arithmatex">\(x_i\)</span>有上界<span class="arithmatex">\(b_i\)</span>，即<span class="arithmatex">\(x_i\leq b_i\)</span>则令<span class="arithmatex">\(P_i=x_i\geq b_i+1\)</span>，则原问题化为求<span class="arithmatex">\(N(\bar{P_1}\cdots\bar{P_n})\)</span></li>
<li>若问题是不等式，则引入新变量使其变为等式</li>
</ol>
</li>
</ul>
<h3 id="_10">排列与组合的生成算法</h3>
<ul>
<li>
<p>（定义8.8）<strong>字典序</strong>：一般情况下，看作符合用<code>strcmp()</code>定义的升序序列即可</p>
</li>
<li>
<p>（引理8.18）对于一个长度固定、确定前缀的字符串，前缀后字符是降序排列的字符串字典序最大，前缀后字符是升序排列的字符串字典序最小</p>
</li>
<li>
<p>计算全排列串<span class="arithmatex">\(a\)</span>的下一个串的算法：</p>
<ol>
<li>从末尾往前找最长的降序序列<span class="arithmatex">\(a_ia{i+1}\cdots a_n\)</span></li>
<li>找该序列中大于该序列前一字符<span class="arithmatex">\(a_{i-1}\)</span>的最小值，交换他们；由于序列降序，实际上就是从后往前找第一个大于<span class="arithmatex">\(a_{i-1}\)</span>的字符。</li>
<li>将该序列变为升序；不难证明这只需要将这个序列反转即可</li>
</ol>
</li>
<li>
<p>计算n元素r组合时一个串<span class="arithmatex">\(a\)</span>的下一个串；由于组合是无序的，为了将组合映射到有序的串，规定这些串应当是升序的；为了方便讨论，将这些串的字符用正整数表示。</p>
<ol>
<li>显然最大的串为<span class="arithmatex">\((n-r+1)\cdots n\)</span>，于是先从右往左找到第一个不等于最大串对应位置字符的字符，也就是从右往左找第一个满足<span class="arithmatex">\(a_i\neq n-r+i\)</span>的下标<span class="arithmatex">\(i\)</span></li>
<li>将<span class="arithmatex">\(a_i\)</span>加一，往后的每一个字符都变为前一字符加一，比如变化后<span class="arithmatex">\(a_i=5\)</span>，则从<span class="arithmatex">\(a_i\)</span>开始往后就是<span class="arithmatex">\(5678\cdots\)</span></li>
</ol>
</li>
</ul>
<h2 id="_11">递推关系式</h2>
<h3 id="_12">技术问题的递推关系式建模</h3>
<ul>
<li>（定义8.9）<strong>递推关系式</strong>是用序列中某些前面的项表示第n项的等式。如果<span class="arithmatex">\(\{a_n\}\)</span>满足一个递推关系式，则称这个序列为他的<strong>解</strong>；如果这个解序列的第n项能使用不含序列中任意项的通项公式表达，则称这个公式为递推关系式的<strong>封闭公式解</strong></li>
<li>为了得到一个问题的递推关系式，需要使用分治思想，将大问题拆成小问题，再逐个解决小问题；可以用集合语言简化叙述</li>
</ul>
<h3 id="_13">线性递推关系式求解</h3>
<ul>
<li><strong>线性</strong>指递推式是乘式的和，每个乘式至多含一个序列前项；<strong>齐次</strong>表示所有项都与序列前项相关；<strong>常系数</strong>表示多项式系数与n无关</li>
<li>（定理8.19）对于一个常系数k阶线性齐次递推关系式</li>
</ul>
<div class="arithmatex">\[
a_n=c_1a_{n-1}+c_2a_{n-2}+\cdots+c_k+a_{n-k}
\]</div>
<p>其中<span class="arithmatex">\(c_1,c_2,\cdots,c_k\)</span>w为实数，且<span class="arithmatex">\(c_k\neq 0\)</span>。方程</p>
<div class="arithmatex">\[
x^k=c_1x^{k-1}+c_2x^{k-2}+\cdots+c_k
\]</div>
<p>称为该递推关系式的<strong>特征方程</strong>。如果这个方程有k个互不相同的根<span class="arithmatex">\(r_1,r_2,\cdots,r_k\)</span>，则序列<span class="arithmatex">\(\{a_n\}\)</span>是该递推关系式的解当且仅当：</p>
<div class="arithmatex">\[
a_n=\beta_1r_1^n+\beta_2r_2^n+\cdots+\beta_kr_k^n
\]</div>
<p>其中<span class="arithmatex">\(\beta_1,\beta_2,\cdots,\beta_k\)</span>是常数，称为这个解的<strong>待定系数</strong>，可由递推关系式的k个初始条件，即序列<span class="arithmatex">\(\{a_n\}\)</span>的k个初值确定</p>
<ul>
<li>（定理8.20）如果特征方程有重根，设有t个不同的根<span class="arithmatex">\(r_1,r_2,\cdots,r_t\)</span>，每个根对应的重数为<span class="arithmatex">\(m_1,m_2,\cdots,m_t\)</span>，则序列<span class="arithmatex">\(\{a_n\}\)</span>是该递推关系式的解当且仅当：</li>
</ul>
<div class="arithmatex">\[
a_n=\sum_{i=1}^n \left(\sum_{j=0}^{m_i}\beta_{i,j}x^j\right)r_i^n
\]</div>
<ul>
<li>
<p>对于一个常系数k阶线性非齐次递推关系式<span class="arithmatex">\(a_n=c_1a_{n-1}+c_2a_{n-2}+\cdots+c_k+a_{n-k}+F(n)\)</span>，记它的<strong>伴随齐次递推关系式</strong>为<span class="arithmatex">\(a_n=c_1a_{n-1}+c_2a_{n-2}+\cdots+c_k+a_{n-k}\)</span>。要求解非齐次方程，先解不考虑初值条件下伴随齐次递推关系式的解，称为<strong>特解</strong>。</p>
</li>
<li>
<p>（定理8.21）如果<span class="arithmatex">\(\{a_n^{(p)}\}\)</span>是一个常系数阶线性非齐次递推关系式的特解，那么它的每个解都具有形式<span class="arithmatex">\(\{a_n^{(p)}+a_n^{(h)}\}\)</span>，其中<span class="arithmatex">\(\{a_n^{(h)}\}\)</span>是它的伴随齐次递推关系式的一个解</p>
</li>
<li>
<p>（定理8.22）对于<span class="arithmatex">\(F(n)=s^n\sum_{i=0}^tb_in^i\)</span>（<span class="arithmatex">\(b_i\)</span>和s是常数）的常系数k阶线性非齐次递推关系式，若s不是它的伴随线性齐次递推式的特征方程的根，则<span class="arithmatex">\(a_n^{(p)}=s^n\sum_{i=0}^tp_in^i\)</span>；若s是它的伴随线性齐次递推式的特征方程的m重根，<span class="arithmatex">\(a_n^{(p)}=n^ms^n\sum_{i=0}^tp_in^i\)</span></p>
</li>
</ul>
<h3 id="_14">分治算法与递推关系式</h3>
<ul>
<li>
<p><strong>分治</strong>是设计递归算法的一种重要思路：将规模为n的问题分解为a个与原问题相同但规模减小，例如大致为n/b的小问题，在求解每个小问题后，将小问题的解治理为原来问题的解。</p>
</li>
<li>
<p>归并排序算法<code>F(l,r)</code>：将序列中区间<code>[l,r]</code>的元素进行升序排序</p>
<ol>
<li>若<span class="arithmatex">\(l=r\)</span>，则区间只有一个元素，直接返回</li>
<li>若<span class="arithmatex">\(l\neq r\)</span>，则取中点<span class="arithmatex">\(m=\lfloor (l+r)/2\rfloor\)</span>，对划分出的两个区间排序，即执行<code>F(l,m)</code>和<code>F(m+1,r)</code></li>
<li>将排好序的两个子区间治理为有序的一个大区间，具体做法是不断从两个子区间未取的数左端选择较小值，依次放入临时区间，数取完后复制回原数组即可完成治理
对区间长度为n的序列运行上述归并排序，需要执行的复制操作次数<code>f(n)=2f(n/2)+2</code></li>
</ol>
</li>
<li>
<p>（定理8.23）<strong>主定理</strong>：设实数值函数<span class="arithmatex">\(f(n)\)</span>是递增函数，且满足递推关系式<span class="arithmatex">\(f(n)=af(n/b)+Cn^d\)</span>，其中<span class="arithmatex">\(a\geq1,b\gt1\)</span>是整数，且<span class="arithmatex">\(C\gt0,d\geq0\)</span>是实数，则：</p>
</li>
</ul>
<div class="arithmatex">\[
f(n)是\left\{ \begin{aligned}
    &amp;O(n^d)         &amp;,a\lt b^d  \\
    &amp;O(n^d\log n)   &amp;,a=   b^d  \\
    &amp;O(n^{\log_b a})&amp;,a\gt b^d
\end{aligned}\right.
\]</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../7-%E5%87%BD%E6%95%B0/" class="btn btn-neutral float-left" title="函数"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../7-%E5%87%BD%E6%95%B0/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../javascripts/mathjax.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
